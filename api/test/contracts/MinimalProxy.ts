
import { ABI } from "../../src/types";
import { ContractStorage } from "../utils";

export default {
  name: "MinimalProxy",
  filename: "MinimalProxyContract.sol",
  arguments: JSON.stringify([]),
  bytecode: "0x608060405234801561001057600080fd5b5061010c806100206000396000f3fe6080604052348015600f57600080fd5b506004361060285760003560e01c80638124b78e14602d575b600080fd5b603c603836600460aa565b6058565b6040516001600160a01b03909116815260200160405180910390f35b6000808260601b9050604051733d602d80600a3d3981f3363d3d373d3d3d363d7360601b81528160148201526e5af43d82803e903d91602b57fd5bf360881b60288201526037816000f0949350505050565b60006020828403121560ba578081fd5b81356001600160a01b038116811460cf578182fd5b939250505056fea2646970667358221220154877bc562cde798b8f377e994a580fd7fcadaf03ba5f884678d00d12d95f6264736f6c63430008040033",
  abi: [{"inputs":[{"internalType":"address","name":"target","type":"address"}],"name":"clone","outputs":[{"internalType":"address","name":"result","type":"address"}],"stateMutability":"nonpayable","type":"function"}] as ABI,
  sources: JSON.stringify({"MinimalProxyContract.sol":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n// original code\n// https://github.com/optionality/clone-factory/blob/master/contracts/CloneFactory.sol\n\ncontract MinimalProxy {\n    function clone(address target) external returns (address result) {\n        // convert address to 20 bytes\n        bytes20 targetBytes = bytes20(target);\n\n        // actual code //\n        // 3d602d80600a3d3981f3363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3\n\n        // creation code //\n        // copy runtime code into memory and return it\n        // 3d602d80600a3d3981f3\n\n        // runtime code //\n        // code to delegatecall to address\n        // 363d3d373d3d3d363d73 address 5af43d82803e903d91602b57fd5bf3\n\n        assembly {\n            /*\n            reads the 32 bytes of memory starting at pointer stored in 0x40\n\n            In solidity, the 0x40 slot in memory is special: it contains the \"free memory pointer\"\n            which points to the end of the currently allocated memory.\n            */\n            let clone := mload(0x40)\n            // store 32 bytes to memory starting at \"clone\"\n            mstore(\n                clone,\n                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\n            )\n\n            /*\n              |              20 bytes                |\n            0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\n                                                      ^\n                                                      pointer\n            */\n            // store 32 bytes to memory starting at \"clone\" + 20 bytes\n            // 0x14 = 20\n            mstore(add(clone, 0x14), targetBytes)\n\n            /*\n              |               20 bytes               |                 20 bytes              |\n            0x3d602d80600a3d3981f3363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe\n                                                                                              ^\n                                                                                              pointer\n            */\n            // store 32 bytes to memory starting at \"clone\" + 40 bytes\n            // 0x28 = 40\n            mstore(\n                add(clone, 0x28),\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\n            )\n\n            /*\n              |               20 bytes               |                 20 bytes              |           15 bytes          |\n            0x3d602d80600a3d3981f3363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3\n            */\n            // create new contract\n            // send 0 Ether\n            // code starts at pointer stored in \"clone\"\n            // code size 0x37 (55 bytes)\n            result := create(0, clone, 0x37)\n        }\n    }\n}"}),
} as ContractStorage
